import osimport pandas as pdimport datetime#%%# =============================================================================#                           Employee class# =============================================================================# Python OOPclass Employee:    # Inicializo variables de la clase / instancias    num_of_emps = 0    raise_amt = 1.04    # Inicializo la clase    def __init__(self, first, last, pay):        # Defino los metodos y el output        self.first = first        self.last = last        self.pay = pay        self.email = f'{self.first}.{self.last}@company.com'        # Cada vez que inicializo una nueva clase aumento el contador        Employee.num_of_emps += 1        # Funcion para obtener el nombre completo    def fullname(self):        return str(self.first) + ' ' + str(self.last)        # Funcion para aplicar aumento    def apply_raise(self):        self.pay = int(self.pay) * self.raise_amt        # Defino una classmethod para actualizar el monto de aumento de la clase    @classmethod    def set_raise_amt(cls, amount):        cls.raise_amt = amount        # Crear un empleado desde un string    @classmethod    def from_string(cls, emp_str):        first, last, pay = emp_str.split('-')        return cls(first, last, pay)        # Metodo statico que no necesita ni class ni self    @staticmethod    def is_workday(day):        if day.weekday() == 5 or day.weekday() == 6:            return False        else:            return True            # Funcion para debuggeo de desarrolladores    def __repr__(self):        return f'Employee({self.first}, {self.last}, {self.pay})'        # Funcion para users    def __str__(self):        return f'{self.fullname()}, {self.email}'        # Defino una funcion custom para la suma de employees    def __add__(self, other):        return self.pay + other.pay        # Defino una nueva funcion para calcular la longitud del empleado    def __len__(self):        return len(self.fullname())        #%%# =============================================================================#                           Subclassing# =============================================================================# Developer subclassclass Developer(Employee):    raise_amount = 1.10    def __init__(self, first, last, pay, prog_lang):        # Hacemos que los argumentos se inicialicen en la parent class        super().__init__(first, last, pay)        # Otra manera de inicializar con los argumentos de la parent class        # Employee.__init__(self, first, last, pay)        self.prog_lang = prog_lang# Manager subclassclass Manager(Employee):    def __init__(self, first, last, pay, employees=None):        super().__init__(first, last, pay)        if employees is None:            self.employees = []        else:            self.employees = employees        def add_emp(self, emp):        if emp not in employees:            self.employees.append(emp)        def remove_emp(self, emp):        if emp in employees:            self.employees.remove(emp)        def print_emp(self):        for empl in self.employees:            print('-->', empl.fullname())#%%